package natclinn.util;

import org.apache.jena.graph.Graph;
import org.apache.jena.graph.Node;
import org.apache.jena.graph.NodeFactory;
import org.apache.jena.graph.Triple;
import org.apache.jena.reasoner.rulesys.RuleContext;
import org.apache.jena.reasoner.rulesys.builtins.BaseBuiltin;
import org.apache.jena.util.iterator.ExtendedIterator;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * Primitive pour lier les produits aux arguments consommateurs via les métadonnées de rôles d'additifs.
 * Crée des instances LinkToArgument pour établir la relation Product -> LinkToArgument -> ProductArgument.
 * 
 * Architecture:
 * - Product → containsIngredientWithRole → AdditiveRole (présence de rôles d'additifs)
 * - Product → hasAdditiveRoleCheck → sans_conservateur / sans_colorant / etc. (absence/vérifications)
 * - AdditiveRoleArgumentBinding → aboutAdditiveRole → AdditiveRole (métadonnées de configuration)
 * - ProductArgument (données enquêtes consommateurs: nameProperty, aim, assertion, verbatim, valueProperty, etc.)
 * 
 * Signature: compareAdditiveRoleProperty(?product)
 * - ?product : ressource Product avec rôles d'additifs et/ou vérifications d'absence
 * 
 * La primitive récupère automatiquement tous les ProductArgument pertinents
 * et teste le matching pour chacun d'eux en fonction des rôles d'additifs du produit.
 * 
 * Processus de matching:
 * 1. Récupération des rôles d'additifs (présence ET absence) du produit
 * 2. Normalisation via les synonymes configurés dans l'ontologie
 * 3. Pour chaque rôle, filtrage des arguments pertinents via additiveRoleFilteringRule
 * 4. Application du filtrage d'antinomie via additiveRoleAntinomyProperties
 * 5. Matching des keywords avec les propriétés de l'argument
 * 6. Vérification de additiveRoleRequired pour validation finale
 * 7. Création d'un LinkToArgument si toutes les conditions sont remplies
 * 
 * Utilise des heuristiques avancées : correspondance exacte, normalisée, par tokens (Jaccard), containment.
 */
public class CompareAdditiveRoleProperty extends BaseBuiltin {

    private static final String ncl;
    private static final String rdf;
    private static final Node HAS_RDF_TYPE;
    private static final Node HAS_ADDITIVE_ROLE;
    private static final Node HAS_ADDITIVE_ROLE_CHECK;
    // Propriétés sur ProductArgument (données consommateurs)
    private static final Node PRODUCT_ARG_NAME_PROPERTY;
    private static final Node PRODUCT_ARG_AIM;
    private static final Node PRODUCT_ARG_ASSERTION;
    private static final Node PRODUCT_ARG_VERBATIM;
    private static final Node PRODUCT_ARG_VALUE_PROPERTY;
    // Propriétés sur AdditiveRoleArgumentBinding (métadonnées de configuration)
    private static final Node BINDING_AGENT_KEYWORDS;
    private static final Node ADDITIVE_ROLE_TYPE_REQUIRED;
    private static final Node ABOUT_ADDITIVE_ROLE_TYPE;
    private static final Node HAS_LINK_TO_ARGUMENT;
    private static final Node HAS_REFERENCE_PRODUCT_ARGUMENT;
    private static final Node INITIATOR;
    private static final Node LINK_NAME_PROPERTY;
    private static final Node LINK_VALUE_PROPERTY;
    // Propriétés de configuration depuis l'ontologie pivot
    private static final Node ADDITIVE_ROLE_TYPE_FILTERING_RULE;
    private static final Node ADDITIVE_ROLE_TYPE_SYNONYM_LABELS;
    private static final Node ADDITIVE_ROLE_TYPE_SELECTION_RULE;
    private static final Node ADDITIVE_ROLE_TYPE_ANTINOMY_PROPERTIES;
    private static final Set<String> STOPWORDS = new HashSet<>(java.util.Arrays.asList(
        "le", "la", "les", "un", "une", "des", "de", "du", "que", "qui", "quoi",
        "et", "ou", "mais", "donc", "car", "ni", "or",
        "ce", "cet", "cette", "ces", "se", "sa", "son", "ses",
        "me", "te", "nous", "vous", "lui", "leur",
        "pas", "plus", "non", "oui", "si", "bien",
        "tout", "tous", "toute", "toutes",
        "mon", "ton", "ma", "ta", "mes", "tes",
        "au", "aux", "en", "dans", "sur", "sous", "pour", "par", "avec", "sans",
        "je", "tu", "il", "elle", "on", "ils", "elles",
        "avoir", "être", "fait", "faire", "être", "ai", "as", "est", "sont", "été"
    ));

    static {
        // Initialisation de la configuration
        new NatclinnConf();
        ncl = NatclinnConf.ncl;
        rdf = NatclinnConf.rdf;
        HAS_RDF_TYPE = NodeFactory.createURI(rdf + "type");
        HAS_ADDITIVE_ROLE = NodeFactory.createURI(ncl + "containsIngredientWithRole");
        HAS_ADDITIVE_ROLE_CHECK = NodeFactory.createURI(ncl + "hasAdditiveRoleCheck");
        PRODUCT_ARG_NAME_PROPERTY = NodeFactory.createURI(ncl + "nameProperty");
        PRODUCT_ARG_AIM = NodeFactory.createURI(ncl + "aim");
        PRODUCT_ARG_ASSERTION = NodeFactory.createURI(ncl + "assertion");
        PRODUCT_ARG_VERBATIM = NodeFactory.createURI(ncl + "verbatim");
        PRODUCT_ARG_VALUE_PROPERTY = NodeFactory.createURI(ncl + "valueProperty");
        BINDING_AGENT_KEYWORDS = NodeFactory.createURI(ncl + "bindingAgentKeywords");
        ADDITIVE_ROLE_TYPE_REQUIRED = NodeFactory.createURI(ncl + "additiveRoleRequired");
        ABOUT_ADDITIVE_ROLE_TYPE = NodeFactory.createURI(ncl + "aboutAdditiveRole");
        HAS_LINK_TO_ARGUMENT = NodeFactory.createURI(ncl + "hasLinkToArgument");
        HAS_REFERENCE_PRODUCT_ARGUMENT = NodeFactory.createURI(ncl + "hasReferenceProductArgument");
        INITIATOR = NodeFactory.createURI(ncl + "initiator");
        LINK_NAME_PROPERTY = NodeFactory.createURI(ncl + "LinkNameProperty");
        LINK_VALUE_PROPERTY = NodeFactory.createURI(ncl + "LinkValueProperty");
        // Propriétés de configuration
        ADDITIVE_ROLE_TYPE_FILTERING_RULE = NodeFactory.createURI(ncl + "additiveRoleFilteringRule");
        ADDITIVE_ROLE_TYPE_SYNONYM_LABELS = NodeFactory.createURI(ncl + "additiveRoleSynonymLabels");
        ADDITIVE_ROLE_TYPE_SELECTION_RULE = NodeFactory.createURI(ncl + "additiveRoleSelectionRule");
        ADDITIVE_ROLE_TYPE_ANTINOMY_PROPERTIES = NodeFactory.createURI(ncl + "additiveRoleAntinomyProperties");
    }

    @Override
    public String getName() {
        return "compareAdditiveRoleProperty";
    }

    @Override
    public int getArgLength() {
        return 1; // product only (arguments retrieved internally)
    }

    @Override
    public boolean bodyCall(Node[] args, int length, RuleContext context) {
        checkArgs(length, context);

        Node productNode = getArg(0, args, context);

        if (!productNode.isURI() && !productNode.isBlank()) return false;
        
        System.out.println("[CompareAdditiveRoleProperty] Processing product: " + productNode.toString());

        Graph g = context.getGraph();

        // 1) Récupérer tous les rôles d'additifs du produit.
        //    On collecte les noms locaux des rôles (e.g., "conservateur", "colorant")
        //    depuis les ressources ncl:containsIngredientWithRole attachées au produit.
        Set<String> additiveRoles = new HashSet<>();

        ExtendedIterator<Triple> itType = g.find(productNode, HAS_ADDITIVE_ROLE, Node.ANY);
        while (itType.hasNext()) {
            Node val = itType.next().getObject();
            if (val.isURI()) {
                String uri = val.getURI();
                String typeName = uri.substring(uri.lastIndexOf('/') + 1);
                additiveRoles.add(typeName.toLowerCase().trim());
            }
        }
        itType.close();
        
        System.out.println("[CompareAdditiveRoleProperty] Additive roles found: " + additiveRoles);

        // 1b) Récupérer les vérifications de rôle d'additif via ncl:hasAdditiveRoleCheck.
        //     Ces vérifications indiquent l'ABSENCE ou des caractéristiques particulières
        //     (e.g., "sans_conservateur", "sans_colorant", "additifs_naturels").
        ExtendedIterator<Triple> itCheck = g.find(productNode, HAS_ADDITIVE_ROLE_CHECK, Node.ANY);
        while (itCheck.hasNext()) {
            Node val = itCheck.next().getObject();
            if (val.isURI()) {
                String uri = val.getURI();
                String checkName = uri.substring(uri.lastIndexOf('/') + 1);
                additiveRoles.add(checkName.toLowerCase().trim());
            }
        }
        itCheck.close();
        System.out.println("[CompareAdditiveRoleProperty] Additive roles after checks: " + additiveRoles);

        // 1c) Normaliser les rôles d'additifs en utilisant les synonymes depuis l'ontologie
        Set<String> normalizedAdditiveRoles = new HashSet<>();
        for (String type : additiveRoles) {
            normalizedAdditiveRoles.addAll(normalizeAdditiveRoleLabels(g, type));
        }
        additiveRoles = normalizedAdditiveRoles;

        // Si aucun rôle d'additif détecté, le produit ne peut être lié à aucun argument.
        if (additiveRoles.isEmpty()) return false;

        // 2) Récupérer TOUS les ProductArgument disponibles
        List<Node> additiveroleArguments = new ArrayList<>();
        ExtendedIterator<Triple> itArgs = g.find(Node.ANY, HAS_RDF_TYPE, NodeFactory.createURI(ncl + "ProductArgument"));
        while (itArgs.hasNext()) {
            Node argNode = itArgs.next().getSubject();
            if (argNode.isURI() || argNode.isBlank()) {
                additiveroleArguments.add(argNode);
            }
        }
        itArgs.close();

        // 3) Pour chaque rôle d'additif du produit, traiter les arguments pertinents
        for (String typeLocal : additiveRoles) {
            Node additiveRoleUri = NodeFactory.createURI(ncl + typeLocal);
            
            // Récupérer tous les arguments pertinents pour ce rôle d'additif (filtrage via additiveRoleFilteringRule)
            List<Node> relevantArguments = getRelevantArgumentsForAdditiveRole(g, additiveroleArguments, typeLocal);
             
            // Appliquer le filtrage des antinomies (via additiveRoleAntinomyProperties + additiveRoleSelectionRule)
            List<Node> filteredArguments = filterAntinomicArguments(g, relevantArguments, typeLocal);
            
            // Traiter chaque argument filtré
            for (Node argumentNode : filteredArguments) {
                // Récupérer les propriétés de l'argument
                Set<String> argProperties = collectArgumentProperties(g, argumentNode, typeLocal);

                // Rechercher tous les AdditiveRoleArgumentBinding ayant ncl:aboutAdditiveRole pointant vers additiveRoleUri
                ExtendedIterator<Triple> itBinding = g.find(Node.ANY, ABOUT_ADDITIVE_ROLE_TYPE, additiveRoleUri);
                while (itBinding.hasNext()) {
                    Node bindingNode = itBinding.next().getSubject();

                    // Extraire les bindingAgentKeywords de ce AdditiveRoleArgumentBinding
                    ExtendedIterator<Triple> itKeywords = g.find(bindingNode, BINDING_AGENT_KEYWORDS, Node.ANY);
                    while (itKeywords.hasNext()) {
                        Node val = itKeywords.next().getObject();
                        if (!val.isLiteral()) continue;
                        String keywordsStr = val.getLiteralLexicalForm();
                        if (keywordsStr == null) continue;

                        // Splitter les mots-clés par virgule et traiter chacun
                        String[] keywords = keywordsStr.split(",");
                        for (String keyword : keywords) {
                            keyword = keyword.trim();
                            if (keyword.isEmpty()) continue;

                            // Comparer chaque mot-clé avec les propriétés du ProductArgument
                            if (matchesAnyArgumentProperty(keyword, argProperties)) {
                                // Si correspondance trouvée, vérifier additiveRoleRequired
                                boolean required = isAdditiveRoleRequired(g, bindingNode);

                                // Si additiveRoleRequired="oui" (ou variantes) → lien accepté
                                if (required) {
                                    // Créer un LinkToArgument instance
                                    createLinkToArgument(g, productNode, argumentNode, additiveRoleUri, keyword, context);
                                    itKeywords.close();
                                    itBinding.close();
                                    // Continuer avec les autres arguments
                                }
                            }
                        }
                    }
                    itKeywords.close();
                }
                itBinding.close();
            }
        }

        return true; // La primitive retourne true si le traitement s'est bien déroulé
    }

    /**
     * Collecte toutes les propriétés pertinentes d'un ProductArgument pour un rôle d'additif spécifique.
     * Inclut : nameProperty, aim, assertion, verbatim, valueProperty
     * PRIORITÉ : valueProperty en premier, puis nameProperty, puis les autres
     * FILTRE PAR RÔLE : Ne collecte que si l'argument est pertinent pour le rôle d'additif
     * @param g le graphe
     * @param argumentNode le noeud ProductArgument
     * @param additiveRole le rôle d'additif (e.g., "conservateur", "colorant")
     * @return ensemble des valeurs de propriétés (vide si non pertinent)
     */
    private Set<String> collectArgumentProperties(Graph g, Node argumentNode, String additiveRole) {
        // Vérifier si l'argument est pertinent pour ce rôle d'additif
        if (!isArgumentRelevantForAdditiveRole(g, argumentNode, additiveRole)) {
            return new HashSet<>(); // Retourner ensemble vide pour ignorer cet argument
        }

        Set<String> properties = new HashSet<>();

        // 1. PRIORITÉ : Collecter valueProperty en premier
        ExtendedIterator<Triple> itValue = g.find(argumentNode, PRODUCT_ARG_VALUE_PROPERTY, Node.ANY);
        while (itValue.hasNext()) {
            Node val = itValue.next().getObject();
            if (val.isLiteral()) {
                String txt = val.getLiteralLexicalForm().trim();
                if (!txt.isEmpty()) {
                    properties.add(txt);
                    // Ajouter aussi les tokens individuels
                    String[] tokens = txt.split("[\\s,;:]+");
                    for (String token : tokens) {
                        token = token.trim().toLowerCase();
                        if (!token.isEmpty() && token.length() > 3 && !STOPWORDS.contains(token)) {
                            properties.add(token);
                        }
                    }
                }
            }
        }
        itValue.close();

        // 2. Ensuite nameProperty
        ExtendedIterator<Triple> itName = g.find(argumentNode, PRODUCT_ARG_NAME_PROPERTY, Node.ANY);
        while (itName.hasNext()) {
            Node val = itName.next().getObject();
            if (val.isLiteral()) {
                String txt = val.getLiteralLexicalForm().trim();
                if (!txt.isEmpty()) {
                    properties.add(txt);
                    // Ajouter aussi les tokens individuels
                    String[] tokens = txt.split("[\\s,;:]+");
                    for (String token : tokens) {
                        token = token.trim().toLowerCase();
                        if (!token.isEmpty() && token.length() > 3 && !STOPWORDS.contains(token)) {
                            properties.add(token);
                        }
                    }
                }
            }
        }
        itName.close();

        // 3. Enfin les autres propriétés (aim, assertion, verbatim)
        Node[] otherPropertyNodes = {PRODUCT_ARG_AIM, PRODUCT_ARG_ASSERTION, PRODUCT_ARG_VERBATIM};
        for (Node propNode : otherPropertyNodes) {
            ExtendedIterator<Triple> it = g.find(argumentNode, propNode, Node.ANY);
            while (it.hasNext()) {
                Node val = it.next().getObject();
                if (val.isLiteral()) {
                    String txt = val.getLiteralLexicalForm().trim();
                    if (!txt.isEmpty()) {
                        properties.add(txt);
                        // Ajouter aussi les tokens individuels
                        String[] tokens = txt.split("[\\s,;:]+");
                        for (String token : tokens) {
                            token = token.trim().toLowerCase();
                            if (!token.isEmpty() && token.length() > 3 && !STOPWORDS.contains(token)) {
                                properties.add(token);
                            }
                        }
                    }
                }
            }
            it.close();
        }

        return properties;
    }

    /**
     * Vérifie si un ProductArgument est pertinent pour un rôle d'additif spécifique.
     * Utilise la règle de filtrage (additiveRoleFilteringRule) configurée dans l'ontologie.
     * @param g le graphe
     * @param argumentNode le noeud ProductArgument
     * @param additiveRole le rôle d'additif (e.g., "conservateur", "colorant")
     * @return true si l'argument est pertinent pour ce rôle
     */
    /**
     * Vérifie si un ProductArgument est pertinent pour un rôle d'additif spécifique.
     * Utilise le mot-clé de filtrage configuré dans l'ontologie.
     * Si aucune règle de filtrage n'est configurée, accepte tous les arguments (pas de pré-filtre).
     * @param g le graphe
     * @param argumentNode le noeud ProductArgument
     * @param additiveRole le rôle d'additif (e.g., "colorant", "conservateur")
     * @return true si l'argument est pertinent pour ce rôle
     */
    private boolean isArgumentRelevantForAdditiveRole(Graph g, Node argumentNode, String additiveRole) {
        // Récupérer la règle de filtrage pour ce rôle d'additif
        String filteringRule = getAdditiveRoleFilteringRule(g, additiveRole);
        if (filteringRule == null || filteringRule.isEmpty()) {
            return true; // Pas de règle configurée → accepter tous les arguments (pas de pré-filtre)
        }
        
        // Appliquer la règle de filtrage
        return applyFilteringRule(g, argumentNode, filteringRule);
    }
    
    /**
     * Récupère tous les arguments pertinents pour un rôle d'additif spécifique.
     * @param g le graphe
     * @param allArguments la liste de tous les arguments disponibles
     * @param additiveRole le rôle d'additif
     * @return liste des arguments pertinents (filtrés via additiveRoleFilteringRule)
     */
    private List<Node> getRelevantArgumentsForAdditiveRole(Graph g, List<Node> allArguments, String additiveRole) {
        List<Node> relevant = new ArrayList<>();
        for (Node argumentNode : allArguments) {
            if (isArgumentRelevantForAdditiveRole(g, argumentNode, additiveRole)) {
                relevant.add(argumentNode);
            }
        }
        return relevant;
    }
    
    /**
     * Filtre les arguments antinomiques en gardant seulement le meilleur selon la règle de sélection.
     * Utilise:
     * - additiveRoleAntinomyProperties : liste des propriétés qui nécessitent un filtrage d'antinomie
     * - additiveRoleSelectionRule : critère de sélection du meilleur argument
     * @param g le graphe
     * @param arguments les arguments pertinents
     * @param additiveRole le rôle d'additif
     * @return liste filtrée des arguments (un seul par propriété antinomique)
     */
    /**
     * Filtre les arguments antinomiques en gardant seulement le meilleur score pour chaque propriété.
     * Utilise les propriétés d'antinomie configurées dans l'ontologie.
     * Si aucune propriété d'antinomie n'est configurée, retourne tous les arguments sans filtrage.
     * @param g le graphe
     * @param arguments les arguments pertinents
     * @param additiveRole le rôle d'additif
     * @return liste filtrée des arguments
     */
    private List<Node> filterAntinomicArguments(Graph g, List<Node> arguments, String additiveRole) {
        // Récupérer les propriétés qui nécessitent un filtrage d'antinomie
        Set<String> antinomyProperties = getAdditiveRoleAntinomyProperties(g, additiveRole);
        
        // Si aucune propriété d'antinomie configurée, retourner tous les arguments (pas de filtrage)
        if (antinomyProperties.isEmpty()) {
            return arguments;
        }
        
        // Grouper les arguments par propriété
        Map<String, List<Node>> argumentsByProperty = new HashMap<>();
        
        for (Node argumentNode : arguments) {
            String nameProperty = getArgumentProperty(g, argumentNode, PRODUCT_ARG_NAME_PROPERTY);
            if (nameProperty != null) {
                argumentsByProperty.computeIfAbsent(nameProperty, k -> new ArrayList<>()).add(argumentNode);
            }
        }
        
        List<Node> filtered = new ArrayList<>();
        
        // Pour chaque groupe de propriétés
        for (Map.Entry<String, List<Node>> entry : argumentsByProperty.entrySet()) {
            String propertyName = entry.getKey();
            List<Node> groupArguments = entry.getValue();
            
            if (antinomyProperties.contains(propertyName) && groupArguments.size() > 1) {
                // Pour les propriétés configurées comme antinomiques, garder seulement l'argument avec le meilleur score
                Node bestArgument = selectBestArgumentForAntinomy(g, groupArguments, additiveRole);
                if (bestArgument != null) {
                    filtered.add(bestArgument);
                }
            } else {
                // Pour les autres propriétés, garder tous les arguments
                filtered.addAll(groupArguments);
            }
        }
        
        return filtered;
    }
    
    /**
     * Récupère les propriétés qui nécessitent un filtrage d'antinomie pour un rôle d'additif.
     * Ces propriétés sont définies via additiveRoleAntinomyProperties dans l'ontologie.
     * @param g le graphe
     * @param additiveRole le rôle d'additif
     * @return ensemble des noms de propriétés antinomiques
     */
    private Set<String> getAdditiveRoleAntinomyProperties(Graph g, String additiveRole) {
        Set<String> antinomyProperties = new HashSet<>();
        Node additiveRoleUri = NodeFactory.createURI(ncl + additiveRole);
        
        ExtendedIterator<Triple> itBinding = g.find(Node.ANY, ABOUT_ADDITIVE_ROLE_TYPE, additiveRoleUri);
        while (itBinding.hasNext()) {
            Node bindingNode = itBinding.next().getSubject();
            
            ExtendedIterator<Triple> itProps = g.find(bindingNode, ADDITIVE_ROLE_TYPE_ANTINOMY_PROPERTIES, Node.ANY);
            while (itProps.hasNext()) {
                Node val = itProps.next().getObject();
                if (val.isLiteral()) {
                    String propsStr = val.getLiteralLexicalForm();
                    if (propsStr != null) {
                        String[] props = propsStr.split(",");
                        for (String prop : props) {
                            String trimmed = prop.trim();
                            if (!trimmed.isEmpty()) {
                                antinomyProperties.add(trimmed);
                            }
                        }
                    }
                }
            }
            itProps.close();
        }
        itBinding.close();
        
        return antinomyProperties;
    }

    /**
     * Récupère la règle de sélection pour un rôle d'additif depuis l'ontologie.
     * Cette règle définit le critère pour choisir le meilleur argument parmi des arguments antinomiques.
     * @param g le graphe
     * @param additiveRole le rôle d'additif
     * @return la règle de sélection (e.g., "avec", "sans") ou null
     */
    private String getAdditiveRoleSelectionRule(Graph g, String additiveRole) {
        Node additiveRoleUri = NodeFactory.createURI(ncl + additiveRole);
        
        ExtendedIterator<Triple> itBinding = g.find(Node.ANY, ABOUT_ADDITIVE_ROLE_TYPE, additiveRoleUri);
        while (itBinding.hasNext()) {
            Node bindingNode = itBinding.next().getSubject();
            
            ExtendedIterator<Triple> itRule = g.find(bindingNode, ADDITIVE_ROLE_TYPE_SELECTION_RULE, Node.ANY);
            while (itRule.hasNext()) {
                Node val = itRule.next().getObject();
                if (val.isLiteral()) {
                    String rule = val.getLiteralLexicalForm();
                    if (rule != null) {
                        itRule.close();
                        itBinding.close();
                        return rule.trim();
                    }
                }
            }
            itRule.close();
        }
        itBinding.close();
        
        return null;
    }

    /**
     * Sélectionne l'argument avec le meilleur score parmi des arguments antinomiques.
     * Utilise la règle de sélection (additiveRoleSelectionRule) pour prioriser certains arguments.
     * Si pas de règle ou pas de match, utilise un système de scoring basé sur les keywords.
     * @param g le graphe
     * @param antinomicArguments les arguments antinomiques
     * @param additiveRole le rôle d'additif
     * @return l'argument avec le meilleur score
     */
    private Node selectBestArgumentForAntinomy(Graph g, List<Node> antinomicArguments, String additiveRole) {
        // Récupérer la règle de sélection
        String selectionRule = getAdditiveRoleSelectionRule(g, additiveRole);
        
        if (selectionRule != null && !selectionRule.isEmpty()) {
            // La règle de sélection est directement le littéral à chercher (ex: "avec")
            String literalToFind = selectionRule.toLowerCase();
            
            // Priorité : sélectionner l'argument qui mentionne explicitement le littéral
            for (Node argumentNode : antinomicArguments) {
                Set<String> argProperties = collectArgumentProperties(g, argumentNode, additiveRole);
                for (String property : argProperties) {
                    if (property.toLowerCase().contains(literalToFind)) {
                        return argumentNode;
                    }
                }
            }
        }
        
        // Fallback : utiliser le scoring basé sur les keywords
        Node bestArgument = null;
        double bestScore = -1;
        
        // Récupérer les mots-clés du binding pour ce rôle d'additif
        Set<String> bindingKeywords = getBindingKeywordsForAdditiveRole(g, additiveRole);
        
        for (Node argumentNode : antinomicArguments) {
            Set<String> argProperties = collectArgumentProperties(g, argumentNode, additiveRole);
            double score = calculateMatchingScore(argProperties, bindingKeywords, additiveRole);
            
            if (score > bestScore) {
                bestScore = score;
                bestArgument = argumentNode;
            }
        }
        
        return bestArgument;
    }
    
    /**
     * Récupère les mots-clés du binding (bindingAgentKeywords) associé à un rôle d'additif.
     * @param g le graphe
     * @param additiveRole le rôle d'additif
     * @return ensemble des mots-clés configurés
     */
    private Set<String> getBindingKeywordsForAdditiveRole(Graph g, String additiveRole) {
        Set<String> keywords = new HashSet<>();
        Node additiveRoleUri = NodeFactory.createURI(ncl + additiveRole);
        
        // Trouver le binding pour ce rôle
        ExtendedIterator<Triple> itBinding = g.find(Node.ANY, ABOUT_ADDITIVE_ROLE_TYPE, additiveRoleUri);
        while (itBinding.hasNext()) {
            Node bindingNode = itBinding.next().getSubject();
            
            // Récupérer les mots-clés
            ExtendedIterator<Triple> itKeywords = g.find(bindingNode, BINDING_AGENT_KEYWORDS, Node.ANY);
            while (itKeywords.hasNext()) {
                Node val = itKeywords.next().getObject();
                if (val.isLiteral()) {
                    String keywordsStr = val.getLiteralLexicalForm();
                    if (keywordsStr != null) {
                        String[] keywordArray = keywordsStr.split(",");
                        for (String keyword : keywordArray) {
                            keywords.add(keyword.trim().toLowerCase());
                        }
                    }
                }
            }
            itKeywords.close();
        }
        itBinding.close();
        
        return keywords;
    }
    
    /**
     * Calcule un score de matching entre les propriétés d'un argument et les mots-clés du binding.
     * Utilise des heuristiques pour évaluer la qualité de la correspondance:
     * - Match exact : 1.5 points
     * - Match normalisé : 1.2 points
     * - Match partiel (containment) : 1.0 point
     * - Présence du keyword sans match parfait : 0.1 point
     * @param argProperties propriétés de l'argument
     * @param keywords mots-clés du binding
     * @param additiveRole le rôle d'additif (pour contexte)
     * @return score normalisé de matching (0.0 à ~2.0)
     */
    private double calculateMatchingScore(Set<String> argProperties, Set<String> keywords, String additiveRole) {
        if (argProperties.isEmpty() || keywords.isEmpty()) return 0.0;

        double totalScore = 0.0;

        for (String keyword : keywords) {
            boolean keywordMatched = false;
            
            for (String argProp : argProperties) {
                if (argProp.toLowerCase().contains(keyword.toLowerCase()) ||
                    keyword.toLowerCase().contains(argProp.toLowerCase())) {
                    
                    keywordMatched = true;
                    double points = 1.0;
                    
                    // Bonus pour les matches exacts ou très proches
                    if (argProp.equalsIgnoreCase(keyword)) {
                        points = 1.5; // Match exact = 1.5 points
                    } else if (normalizeString(argProp).equals(normalizeString(keyword))) {
                        points = 1.2; // Match normalisé = 1.2 points
                    } else {
                        points = 1.0; // Match partiel = 1.0 point
                    }
                    
                    totalScore += points;
                    break; // Un mot-clé matché compte une fois
                }
            }
            
            if (!keywordMatched) {
                totalScore += 0.1; // Petit bonus pour les mots-clés présents même sans match parfait
            }
        }

        double finalScore = totalScore / keywords.size(); // Normaliser par nombre de mots-clés
        
        return finalScore;
    }

    /**
     * Normalise un label de rôle d'additif en utilisant les synonymes depuis l'ontologie.
     * Permet de gérer les variantes de noms (e.g., "conservateur" = "agent_conservateur").
     * @param g le graphe
     * @param originalLabel le label original du rôle
     * @return ensemble des labels normalisés (incluant l'original)
     */
    private Set<String> normalizeAdditiveRoleLabels(Graph g, String originalLabel) {
        Set<String> normalizedLabels = new HashSet<>();
        normalizedLabels.add(originalLabel); // Toujours inclure l'original
        
        // Chercher tous les bindings qui ont ce rôle comme aboutAdditiveRole
        Node additiveRoleUri = NodeFactory.createURI(ncl + originalLabel);
        ExtendedIterator<Triple> itBinding = g.find(Node.ANY, ABOUT_ADDITIVE_ROLE_TYPE, additiveRoleUri);
        while (itBinding.hasNext()) {
            Node bindingNode = itBinding.next().getSubject();
            
            // Récupérer les synonymes
            ExtendedIterator<Triple> itSynonyms = g.find(bindingNode, ADDITIVE_ROLE_TYPE_SYNONYM_LABELS, Node.ANY);
            while (itSynonyms.hasNext()) {
                Node val = itSynonyms.next().getObject();
                if (val.isLiteral()) {
                    String synonymsStr = val.getLiteralLexicalForm();
                    if (synonymsStr != null) {
                        String[] synonyms = synonymsStr.split(",");
                        for (String synonym : synonyms) {
                            String normalized = synonym.trim();
                            if (!normalized.isEmpty()) {
                                normalizedLabels.add(normalized);
                            }
                        }
                    }
                }
            }
            itSynonyms.close();
        }
        itBinding.close();
        
        return normalizedLabels;
    }

    /**
     * Récupère la règle de filtrage (additiveRoleFilteringRule) pour un rôle d'additif depuis l'ontologie.
     * Cette règle définit le mot-clé qui doit être présent dans les propriétés de l'argument
     * pour qu'il soit considéré comme pertinent pour ce rôle.
     * @param g le graphe
     * @param additiveRole le rôle d'additif
     * @return le mot-clé de filtrage ou null
     */
    private String getAdditiveRoleFilteringRule(Graph g, String additiveRole) {
        Node additiveRoleUri = NodeFactory.createURI(ncl + additiveRole);
        
        ExtendedIterator<Triple> itBinding = g.find(Node.ANY, ABOUT_ADDITIVE_ROLE_TYPE, additiveRoleUri);
        while (itBinding.hasNext()) {
            Node bindingNode = itBinding.next().getSubject();
            
            ExtendedIterator<Triple> itRule = g.find(bindingNode, ADDITIVE_ROLE_TYPE_FILTERING_RULE, Node.ANY);
            while (itRule.hasNext()) {
                Node val = itRule.next().getObject();
                if (val.isLiteral()) {
                    String rule = val.getLiteralLexicalForm();
                    if (rule != null) {
                        itRule.close();
                        itBinding.close();
                        return rule.trim();
                    }
                }
            }
            itRule.close();
        }
        itBinding.close();
        
        return null;
    }

    /**
     * Applique une règle de filtrage à un argument en vérifiant la présence du mot-clé.
     * Vérifie si le mot-clé de filtrage apparaît dans valueProperty ou nameProperty de l'argument.
     * @param g le graphe
     * @param argumentNode le noeud argument
     * @param filteringKeyword le mot-clé de filtrage (ex: "conservateur", "colorant")
     * @return true si l'argument contient le mot-clé dans ses propriétés principales
     */
    private boolean applyFilteringRule(Graph g, Node argumentNode, String filteringKeyword) {
        // Récupérer les propriétés de l'argument
        Set<String> argProperties = new HashSet<>();
        
        // valueProperty
        ExtendedIterator<Triple> itValue = g.find(argumentNode, PRODUCT_ARG_VALUE_PROPERTY, Node.ANY);
        while (itValue.hasNext()) {
            Node val = itValue.next().getObject();
            if (val.isLiteral()) {
                String prop = val.getLiteralLexicalForm().toLowerCase().trim();
                if (!prop.isEmpty()) {
                    argProperties.add(prop);
                }
            }
        }
        itValue.close();
        
        // nameProperty
        ExtendedIterator<Triple> itName = g.find(argumentNode, PRODUCT_ARG_NAME_PROPERTY, Node.ANY);
        while (itName.hasNext()) {
            Node val = itName.next().getObject();
            if (val.isLiteral()) {
                String prop = val.getLiteralLexicalForm().toLowerCase().trim();
                if (!prop.isEmpty()) {
                    argProperties.add(prop);
                }
            }
        }
        itName.close();
        
        // Vérifier si le mot-clé est présent dans les propriétés de l'argument
        String keyword = filteringKeyword.toLowerCase();
        return argProperties.stream().anyMatch(prop -> prop.contains(keyword));
    }

    /**
     * Crée une instance LinkToArgument pour établir la relation Product -> ProductArgument.
     * Structure créée:
     * - Product → hasLinkToArgument → LinkToArgument
     * - LinkToArgument → hasReferenceProductArgument → ProductArgument
     * - LinkToArgument → initiator → "AdditiveRole"
     * - LinkToArgument →  → "For"
     * - LinkToArgument → LinkNameProperty → propertyName (keyword matché)
     * - LinkToArgument → LinkValueProperty → URI du rôle d'additif
     * @param g le graphe
     * @param productNode le produit
     * @param argumentNode l'argument consommateur
     * @param additiveRoleNode le rôle d'additif
     * @param propertyName le nom de la propriété matchée (keyword)
     * @param context le contexte de règle pour ajouter les triples
     */
    private void createLinkToArgument(Graph g, Node productNode, Node argumentNode, Node additiveRoleNode, String propertyName, RuleContext context) {
        // Créer un nouvel identifiant unique pour le LinkToArgument
        String linkId = "LinkToArgument_" + System.currentTimeMillis() + "_" + Math.abs((productNode.toString() + argumentNode.toString()).hashCode());
        Node linkNode = NodeFactory.createURI(ncl + linkId);

        // Créer les triples pour le LinkToArgument en utilisant RuleContext pour éviter ConcurrentModificationException
        // Product -> hasLinkToArgument -> LinkToArgument
        Triple t1 = Triple.create(productNode, HAS_LINK_TO_ARGUMENT, linkNode);
        context.add(t1);

        // LinkToArgument -> hasReferenceProductArgument -> ProductArgument
        Triple t2 = Triple.create(linkNode, HAS_REFERENCE_PRODUCT_ARGUMENT, argumentNode);
        context.add(t2);

        // LinkToArgument -> initiator -> "AdditiveRole"
        Node initiatorValue = NodeFactory.createLiteralString("AdditiveRole");
        Triple t3 = Triple.create(linkNode, INITIATOR, initiatorValue);
        context.add(t3);

        // LinkToArgument -> LinkNameProperty -> propertyName
        Node nameValue = NodeFactory.createLiteralString(propertyName);
        Triple t5 = Triple.create(linkNode, LINK_NAME_PROPERTY, nameValue);
        context.add(t5);

        // LinkToArgument -> LinkValueProperty -> rôle d'additif type URI
        String additiveroleUri = additiveRoleNode.isURI() ? additiveRoleNode.getURI() : additiveRoleNode.toString();
        Node valueNode = NodeFactory.createLiteralString(additiveroleUri);
        Triple t6 = Triple.create(linkNode, LINK_VALUE_PROPERTY, valueNode);
        context.add(t6);
    }

    /**
     * Vérifie si une propriété de métadonnées (keyword) match avec n'importe quelle propriété d'argument.
     * Utilise des heuristiques avancées :
     * 1. Comparaison exacte (insensible à la casse)
     * 2. Comparaison normalisée (sans accents ni caractères spéciaux)
     * 3. Comparaison par tokens avec score Jaccard (au moins 50% de tokens en commun)
     * 4. Containment (un contient l'autre après normalisation)
     * @param metadataProp la propriété des métadonnées (keyword du binding)
     * @param argProperties l'ensemble des propriétés de l'argument
     * @return true si correspondance trouvée selon au moins une heuristique
     */
    private boolean matchesAnyArgumentProperty(String metadataProp, Set<String> argProperties) {
        for (String argProp : argProperties) {
            // 1. Comparaison exacte (insensible à la casse)
            if (argProp.equalsIgnoreCase(metadataProp)) {
                return true;
            }
            
            // 2. Comparaison normalisée (suppression accents et caractères spéciaux)
            if (normalizeString(argProp).equals(normalizeString(metadataProp))) {
                return true;
            }
            
            // 3. Comparaison par tokens (Jaccard-like)
            if (tokenOverlap(metadataProp, argProp) >= 0.5) { // Au moins 50% de tokens en commun
                return true;
            }
            
            // 4. Containment (un contient l'autre après normalisation)
            String normMeta = normalizeString(metadataProp);
            String normArg = normalizeString(argProp);
            if (!normMeta.isEmpty() && !normArg.isEmpty() && (normMeta.contains(normArg) || normArg.contains(normMeta))) {
                return true;
            }
        }
        return false;
    }

    /**
     * Calcule le taux de chevauchement des tokens entre deux chaînes (similarité Jaccard).
     * Intersection(tokens1, tokens2) / Union(tokens1, tokens2)
     * @param s1 première chaîne
     * @param s2 deuxième chaîne
     * @return taux de chevauchement (0.0 à 1.0)
     */
    private double tokenOverlap(String s1, String s2) {
        Set<String> tokens1 = tokenize(normalizeString(s1));
        Set<String> tokens2 = tokenize(normalizeString(s2));
        
        if (tokens1.isEmpty() && tokens2.isEmpty()) return 1.0;
        if (tokens1.isEmpty() || tokens2.isEmpty()) return 0.0;
        
        Set<String> intersection = new HashSet<>(tokens1);
        intersection.retainAll(tokens2);
        
        Set<String> union = new HashSet<>(tokens1);
        union.addAll(tokens2);
        
        return (double) intersection.size() / union.size();
    }

    /**
     * Tokenize une chaîne normalisée en mots individuels.
     * Ignore les tokens trop courts (≤ 2 caractères) pour éviter le bruit.
     * @param str la chaîne à tokenizer
     * @return ensemble des tokens significatifs
     */
    private Set<String> tokenize(String str) {
        Set<String> tokens = new HashSet<>();
        String[] parts = str.split("\\s+");
        for (String part : parts) {
            part = part.trim();
            if (!part.isEmpty() && part.length() > 2) { // Ignorer les tokens trop courts
                tokens.add(part);
            }
        }
        return tokens;
    }

    /**
     * Vérifie si la propriété additiveRoleRequired d'un AdditiveRoleArgumentBinding
     * indique que le rôle d'additif est obligatoire pour créer un lien.
     * 
     * Logique de validation :
     * 1. Vérifier d'abord la correspondance keyword (bindingAgentKeywords vs propriétés argument)
     * 2. Si pas de correspondance → rejet (return false)
     * 3. Si correspondance ET additiveRoleRequired="oui" → lien créé (return true)
     * 4. Si correspondance ET additiveRoleRequired≠"oui" → rejet (return false)
     * 
     * Valeurs acceptées pour "oui" : oui, yes, ok (insensible à la casse)
     * 
     * @param g Le graphe RDF contenant les données.
     * @param bindingNode Le nœud AdditiveRoleArgumentBinding à vérifier.
     * @return true si additiveRoleRequired indique "oui", false sinon.
     */
    private boolean isAdditiveRoleRequired(Graph g, Node bindingNode) {
        ExtendedIterator<Triple> itRequired = g.find(bindingNode, ADDITIVE_ROLE_TYPE_REQUIRED, Node.ANY);
        while (itRequired.hasNext()) {
            Node val = itRequired.next().getObject();
            if (val.isLiteral()) {
                String required = val.getLiteralLexicalForm();
                if (required != null) {
                    String req = required.trim().toLowerCase();
                    if (req.equals("oui") || req.equals("yes") || req.equals("ok")) {
                        itRequired.close();
                        return true;
                    }
                }
            }
        }
        itRequired.close();
        return false;
    }

    /**
     * Récupère la valeur d'une propriété spécifique d'un argument.
     * @param g le graphe
     * @param argumentNode le noeud argument
     * @param property la propriété à récupérer (ex: nameProperty, valueProperty)
     * @return la valeur de la propriété ou null si absente
     */
    private String getArgumentProperty(Graph g, Node argumentNode, Node property) {
        ExtendedIterator<Triple> it = g.find(argumentNode, property, Node.ANY);
        while (it.hasNext()) {
            Node val = it.next().getObject();
            if (val.isLiteral()) {
                String result = val.getLiteralLexicalForm();
                it.close();
                return result;
            }
        }
        it.close();
        return null;
    }

    /**
     * Normalise une chaîne de caractères pour comparaison insensible aux accents et à la ponctuation.
     * Transformations appliquées :
     * - Conversion en minuscules
     * - Remplacement des caractères accentués par leur équivalent non accentué
     * - Suppression de tous les caractères non alphanumériques
     * 
     * Cette normalisation permet une comparaison sémantique robuste entre :
     * - ProductArgument properties (données consommateurs)
     * - AdditiveRoleArgumentBinding keywords (métadonnées de configuration)
     * 
     * @param str La chaîne à normaliser.
     * @return La chaîne normalisée (minuscules, sans accents, alphanumérique uniquement).
     */
    private String normalizeString(String str) {
        if (str == null) return "";
        return str.toLowerCase()
                .replaceAll("[àáâãäå]", "a")
                .replaceAll("[èéêë]", "e")
                .replaceAll("[ìíîï]", "i")
                .replaceAll("[òóôõö]", "o")
                .replaceAll("[ùúûü]", "u")
                .replaceAll("[ýÿ]", "y")
                .replaceAll("[ç]", "c")
                .replaceAll("[^a-z0-9]", "")
                .trim();
    }
}
