package natclinn.util;

import org.apache.jena.graph.Graph;
import org.apache.jena.graph.Node;
import org.apache.jena.graph.NodeFactory;
import org.apache.jena.graph.Triple;
import org.apache.jena.reasoner.rulesys.RuleContext;
import org.apache.jena.reasoner.rulesys.builtins.BaseBuiltin;
import org.apache.jena.util.iterator.ExtendedIterator;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * Primitive pour lier les produits aux arguments consommateurs via les origines contrôlées des ingrédients.
 * Crée des instances LinkToArgument pour établir la relation Product -> LinkToArgument -> ProductArgument.
 *
 * Signature: compareOriginProperty(?product, ?productArgument)
 * - ?product : ressource Product avec ingrédients et/ou vérifications d'absence d'origine
 * - ?productArgument : ressource ProductArgument (données consommateurs)
 *
 * Retourne true si les origines des ingrédients du produit matchent
 * avec les propriétés du ProductArgument via les métadonnées d'origine.
 * Crée alors un LinkToArgument pour établir le lien.
 */
public class CompareControlledOriginTypeProperty extends BaseBuiltin {

    private static final String ncl;
    private static final String rdf;
    private static final Node HAS_RDF_TYPE;
    private static final Node HAS_CONTROLLED_ORIGIN_TYPE;
    private static final Node HAS_ORIGIN_CHECK;
    // Propriétés ProductArgument
    private static final Node PRODUCT_ARG_NAME_PROPERTY;
    private static final Node PRODUCT_ARG_AIM;
    private static final Node PRODUCT_ARG_ASSERTION;
    private static final Node PRODUCT_ARG_VERBATIM;
    private static final Node PRODUCT_ARG_VALUE_PROPERTY;
    // Propriétés ControlledOriginTypeArgumentBinding
    private static final Node BINDING_AGENT_KEYWORDS;
    private static final Node ORIGIN_REQUIRED;
    private static final Node ABOUT_ORIGIN;
    private static final Node ORIGIN_FILTERING_RULE;
    private static final Node ORIGIN_SYNONYM_LABELS;
    private static final Node ORIGIN_SELECTION_RULE;
    private static final Node ORIGIN_ANTINOMY_PROPERTIES;
    private static final Set<String> STOPWORDS = new HashSet<>(java.util.Arrays.asList(
        "le", "la", "les", "un", "une", "des", "de", "du", "que", "qui", "quoi",
        "et", "ou", "mais", "donc", "car", "ni", "or",
        "ce", "cet", "cette", "ces", "se", "sa", "son", "ses",
        "me", "te", "nous", "vous", "lui", "leur",
        "pas", "plus", "non", "oui", "si", "bien",
        "tout", "tous", "toute", "toutes",
        "mon", "ton", "ma", "ta", "mes", "tes",
        "au", "aux", "en", "dans", "sur", "sous", "pour", "par", "avec", "sans",
        "je", "tu", "il", "elle", "on", "ils", "elles",
        "avoir", "être", "fait", "faire", "être", "ai", "as", "est", "sont", "été"
    ));
    private static final Node HAS_LINK_TO_ARGUMENT;
    private static final Node HAS_REFERENCE_PRODUCT_ARGUMENT;
    private static final Node INITIATOR;
    private static final Node LINK_NAME_PROPERTY;
    private static final Node LINK_VALUE_PROPERTY;

    static {
        new NatclinnConf();
        ncl = NatclinnConf.ncl;
        rdf = NatclinnConf.rdf;
        HAS_RDF_TYPE = NodeFactory.createURI(rdf + "type");
        HAS_CONTROLLED_ORIGIN_TYPE = NodeFactory.createURI(ncl + "hasControlledOriginType");
        HAS_ORIGIN_CHECK = NodeFactory.createURI(ncl + "hasOriginCheck");
        PRODUCT_ARG_NAME_PROPERTY = NodeFactory.createURI(ncl + "nameProperty");
        PRODUCT_ARG_AIM = NodeFactory.createURI(ncl + "aim");
        PRODUCT_ARG_ASSERTION = NodeFactory.createURI(ncl + "assertion");
        PRODUCT_ARG_VERBATIM = NodeFactory.createURI(ncl + "verbatim");
        PRODUCT_ARG_VALUE_PROPERTY = NodeFactory.createURI(ncl + "valueProperty");
        BINDING_AGENT_KEYWORDS = NodeFactory.createURI(ncl + "bindingAgentKeywords");
        ORIGIN_REQUIRED = NodeFactory.createURI(ncl + "originRequired");
        ABOUT_ORIGIN = NodeFactory.createURI(ncl + "aboutOrigin");
        ORIGIN_FILTERING_RULE = NodeFactory.createURI(ncl + "originFilteringRule");
        ORIGIN_SYNONYM_LABELS = NodeFactory.createURI(ncl + "originSynonymLabels");
        ORIGIN_SELECTION_RULE = NodeFactory.createURI(ncl + "originSelectionRule");
        ORIGIN_ANTINOMY_PROPERTIES = NodeFactory.createURI(ncl + "originAntinomyProperties");
        HAS_LINK_TO_ARGUMENT = NodeFactory.createURI(ncl + "hasLinkToArgument");
        HAS_REFERENCE_PRODUCT_ARGUMENT = NodeFactory.createURI(ncl + "hasReferenceProductArgument");
        INITIATOR = NodeFactory.createURI(ncl + "initiator");
        LINK_NAME_PROPERTY = NodeFactory.createURI(ncl + "LinkNameProperty");
        LINK_VALUE_PROPERTY = NodeFactory.createURI(ncl + "LinkValueProperty");
    }

    @Override
    public String getName() {
        return "compareControlledOriginTypeProperty";
    }

    @Override
    public int getArgLength() {
        return 1; // product only (arguments récupérés automatiquement)
    }

    @Override
    public boolean bodyCall(Node[] args, int length, RuleContext context) {
        checkArgs(length, context);

        Node productNode = getArg(0, args, context);
        if (!productNode.isURI() && !productNode.isBlank()) return false;

        Graph g = context.getGraph();

        // 1) Récupérer toutes les origines du produit (présence + vérifications)
        Set<String> originTypes = new HashSet<>();

        ExtendedIterator<Triple> itOrigin = g.find(productNode, HAS_CONTROLLED_ORIGIN_TYPE, Node.ANY);
        while (itOrigin.hasNext()) {
            Node val = itOrigin.next().getObject();
            if (val.isURI()) {
                String uri = val.getURI();
                String local = uri.substring(uri.lastIndexOf('/') + 1);
                originTypes.add(local.toLowerCase().trim());
            }
        }
        itOrigin.close();

        ExtendedIterator<Triple> itCheck = g.find(productNode, HAS_ORIGIN_CHECK, Node.ANY);
        while (itCheck.hasNext()) {
            Node val = itCheck.next().getObject();
            if (val.isURI()) {
                String uri = val.getURI();
                String local = uri.substring(uri.lastIndexOf('/') + 1);
                originTypes.add(local.toLowerCase().trim());
            }
        }
        itCheck.close();

        // 1b) Normaliser via synonymes ontologie
        Set<String> normalizedOrigins = new HashSet<>();
        for (String type : originTypes) {
            normalizedOrigins.addAll(normalizeOriginLabels(g, type));
        }
        originTypes = normalizedOrigins;

        if (originTypes.isEmpty()) return false;

        // 2) Récupérer tous les ProductArgument
        List<Node> originArguments = new ArrayList<>();
        ExtendedIterator<Triple> itArgs = g.find(Node.ANY, HAS_RDF_TYPE, NodeFactory.createURI(ncl + "ProductArgument"));
        while (itArgs.hasNext()) {
            Node argNode = itArgs.next().getSubject();
            if (argNode.isURI() || argNode.isBlank()) {
                originArguments.add(argNode);
            }
        }
        itArgs.close();

        // 3) Pour chaque origine du produit, traiter les arguments pertinents
        for (String originLocal : originTypes) {
            Node originUri = NodeFactory.createURI(ncl + originLocal);

            List<Node> relevantArguments = getRelevantArgumentsForOrigin(g, originArguments, originLocal);

            List<Node> filteredArguments = filterAntinomicArguments(g, relevantArguments, originLocal);

            for (Node argumentNode : filteredArguments) {
                Set<String> argProperties = collectArgumentProperties(g, argumentNode, originLocal);

                ExtendedIterator<Triple> itBinding = g.find(Node.ANY, ABOUT_ORIGIN, originUri);
                while (itBinding.hasNext()) {
                    Node bindingNode = itBinding.next().getSubject();

                    // Mots-clés du binding (ou fallback sur bindingAgentNameProperty si présent)
                    Set<String> bindingKeywords = getBindingKeywordsForOrigin(g, bindingNode);

                    for (String keyword : bindingKeywords) {
                        if (keyword.isEmpty()) continue;
                        if (matchesAnyArgumentProperty(keyword, argProperties)) {
                            boolean required = isOriginRequired(g, bindingNode);
                            if (required) {
                                createLinkToArgument(g, productNode, argumentNode, originUri, keyword, context);
                                itBinding.close();
                                break;
                            }
                        }
                    }
                }
                itBinding.close();
            }
        }

        return true; // Traite tous les arguments
    }

    /**
     * Collecte les propriétés pertinentes d'un ProductArgument pour une origine donnée.
     */
    private Set<String> collectArgumentProperties(Graph g, Node argumentNode, String originType) {
        if (!isArgumentRelevantForOrigin(g, argumentNode, originType)) {
            return new HashSet<>();
        }

        Set<String> properties = new HashSet<>();

        ExtendedIterator<Triple> itValue = g.find(argumentNode, PRODUCT_ARG_VALUE_PROPERTY, Node.ANY);
        while (itValue.hasNext()) {
            Node val = itValue.next().getObject();
            if (val.isLiteral()) {
                String txt = val.getLiteralLexicalForm().trim();
                if (!txt.isEmpty()) {
                    properties.add(txt);
                    addTokens(properties, txt);
                }
            }
        }
        itValue.close();

        ExtendedIterator<Triple> itName = g.find(argumentNode, PRODUCT_ARG_NAME_PROPERTY, Node.ANY);
        while (itName.hasNext()) {
            Node val = itName.next().getObject();
            if (val.isLiteral()) {
                String txt = val.getLiteralLexicalForm().trim();
                if (!txt.isEmpty()) {
                    properties.add(txt);
                    addTokens(properties, txt);
                }
            }
        }
        itName.close();

        Node[] otherProps = {PRODUCT_ARG_AIM, PRODUCT_ARG_ASSERTION, PRODUCT_ARG_VERBATIM};
        for (Node propNode : otherProps) {
            ExtendedIterator<Triple> it = g.find(argumentNode, propNode, Node.ANY);
            while (it.hasNext()) {
                Node val = it.next().getObject();
                if (val.isLiteral()) {
                    String txt = val.getLiteralLexicalForm().trim();
                    if (!txt.isEmpty()) {
                        properties.add(txt);
                        addTokens(properties, txt);
                    }
                }
            }
            it.close();
        }

        return properties;
    }

    private void addTokens(Set<String> properties, String txt) {
        String[] tokens = txt.split("[\\s,;:]+");
        for (String token : tokens) {
            token = token.trim().toLowerCase();
            if (!token.isEmpty() && token.length() > 3 && !STOPWORDS.contains(token)) {
                properties.add(token);
            }
        }
    }

    private boolean isArgumentRelevantForOrigin(Graph g, Node argumentNode, String originType) {
        String filteringRule = getOriginFilteringRule(g, originType);
        if (filteringRule == null || filteringRule.isEmpty()) {
            return true; // Pas de pré-filtre
        }
        return applyFilteringRule(g, argumentNode, filteringRule);
    }

    private List<Node> getRelevantArgumentsForOrigin(Graph g, List<Node> allArguments, String originType) {
        List<Node> relevant = new ArrayList<>();
        for (Node argumentNode : allArguments) {
            if (isArgumentRelevantForOrigin(g, argumentNode, originType)) {
                relevant.add(argumentNode);
            }
        }
        return relevant;
    }

    private List<Node> filterAntinomicArguments(Graph g, List<Node> arguments, String originType) {
        Set<String> antinomyProperties = getOriginAntinomyProperties(g, originType);
        if (antinomyProperties.isEmpty()) return arguments;

        Map<String, List<Node>> byProperty = new HashMap<>();
        for (Node argumentNode : arguments) {
            String nameProperty = getArgumentProperty(g, argumentNode, PRODUCT_ARG_NAME_PROPERTY);
            if (nameProperty != null) {
                byProperty.computeIfAbsent(nameProperty, k -> new ArrayList<>()).add(argumentNode);
            }
        }

        List<Node> filtered = new ArrayList<>();
        for (Map.Entry<String, List<Node>> entry : byProperty.entrySet()) {
            String propertyName = entry.getKey();
            List<Node> group = entry.getValue();

            if (antinomyProperties.contains(propertyName) && group.size() > 1) {
                Node best = selectBestArgumentForAntinomy(g, group, originType);
                if (best != null) filtered.add(best);
            } else {
                filtered.addAll(group);
            }
        }

        return filtered;
    }

    private Set<String> getOriginAntinomyProperties(Graph g, String originType) {
        Set<String> antinomyProperties = new HashSet<>();
        Node originUri = NodeFactory.createURI(ncl + originType);

        ExtendedIterator<Triple> itBinding = g.find(Node.ANY, ABOUT_ORIGIN, originUri);
        while (itBinding.hasNext()) {
            Node bindingNode = itBinding.next().getSubject();

            ExtendedIterator<Triple> itProps = g.find(bindingNode, ORIGIN_ANTINOMY_PROPERTIES, Node.ANY);
            while (itProps.hasNext()) {
                Node val = itProps.next().getObject();
                if (val.isLiteral()) {
                    String propsStr = val.getLiteralLexicalForm();
                    if (propsStr != null) {
                        String[] props = propsStr.split(",");
                        for (String prop : props) {
                            String trimmed = prop.trim();
                            if (!trimmed.isEmpty()) antinomyProperties.add(trimmed);
                        }
                    }
                }
            }
            itProps.close();
        }
        itBinding.close();

        return antinomyProperties;
    }

    private String getOriginSelectionRule(Graph g, String originType) {
        Node originUri = NodeFactory.createURI(ncl + originType);
        ExtendedIterator<Triple> itBinding = g.find(Node.ANY, ABOUT_ORIGIN, originUri);
        while (itBinding.hasNext()) {
            Node bindingNode = itBinding.next().getSubject();
            ExtendedIterator<Triple> itRule = g.find(bindingNode, ORIGIN_SELECTION_RULE, Node.ANY);
            while (itRule.hasNext()) {
                Node val = itRule.next().getObject();
                if (val.isLiteral()) {
                    String rule = val.getLiteralLexicalForm();
                    if (rule != null) {
                        itRule.close();
                        itBinding.close();
                        return rule.trim();
                    }
                }
            }
            itRule.close();
        }
        itBinding.close();
        return null;
    }

    private Node selectBestArgumentForAntinomy(Graph g, List<Node> antinomicArguments, String originType) {
        String selectionRule = getOriginSelectionRule(g, originType);
        if (selectionRule != null && !selectionRule.isEmpty()) {
            String literalToFind = selectionRule.toLowerCase();
            for (Node argumentNode : antinomicArguments) {
                Set<String> argProps = collectArgumentProperties(g, argumentNode, originType);
                for (String prop : argProps) {
                    if (prop.toLowerCase().contains(literalToFind)) {
                        return argumentNode;
                    }
                }
            }
        }

        Set<String> bindingKeywords = getBindingKeywordsForOriginType(g, originType);
        Node best = null;
        double bestScore = -1;
        for (Node argumentNode : antinomicArguments) {
            Set<String> argProps = collectArgumentProperties(g, argumentNode, originType);
            double score = calculateMatchingScore(argProps, bindingKeywords, originType);
            if (score > bestScore) {
                bestScore = score;
                best = argumentNode;
            }
        }
        return best;
    }

    private Set<String> getBindingKeywordsForOrigin(Graph g, Node bindingNode) {
        Set<String> keywords = new HashSet<>();

        ExtendedIterator<Triple> itKeywords = g.find(bindingNode, BINDING_AGENT_KEYWORDS, Node.ANY);
        while (itKeywords.hasNext()) {
            Node val = itKeywords.next().getObject();
            if (val.isLiteral()) {
                String keywordsStr = val.getLiteralLexicalForm();
                if (keywordsStr != null) {
                    String[] keywordArray = keywordsStr.split(",");
                    for (String keyword : keywordArray) {
                        keywords.add(keyword.trim().toLowerCase());
                    }
                }
            }
        }
        itKeywords.close();

        // Fallback : utiliser bindingAgentNameProperty si aucun mot-clé
        if (keywords.isEmpty()) {
            ExtendedIterator<Triple> itName = g.find(bindingNode, NodeFactory.createURI(ncl + "bindingAgentNameProperty"), Node.ANY);
            while (itName.hasNext()) {
                Node val = itName.next().getObject();
                if (val.isLiteral()) {
                    String kw = val.getLiteralLexicalForm();
                    if (kw != null && !kw.trim().isEmpty()) {
                        keywords.add(kw.trim().toLowerCase());
                    }
                }
            }
            itName.close();
        }

        return keywords;
    }

    private Set<String> getBindingKeywordsForOriginType(Graph g, String originType) {
        Set<String> keywords = new HashSet<>();
        Node originUri = NodeFactory.createURI(ncl + originType);
        ExtendedIterator<Triple> itBinding = g.find(Node.ANY, ABOUT_ORIGIN, originUri);
        while (itBinding.hasNext()) {
            Node bindingNode = itBinding.next().getSubject();
            keywords.addAll(getBindingKeywordsForOrigin(g, bindingNode));
        }
        itBinding.close();
        return keywords;
    }

    private double calculateMatchingScore(Set<String> argProperties, Set<String> keywords, String originType) {
        if (argProperties.isEmpty() || keywords.isEmpty()) return 0.0;

        double totalScore = 0.0;
        for (String keyword : keywords) {
            boolean matched = false;
            for (String argProp : argProperties) {
                if (argProp.toLowerCase().contains(keyword.toLowerCase()) || keyword.toLowerCase().contains(argProp.toLowerCase())) {
                    matched = true;
                    double points = 1.0;
                    if (argProp.equalsIgnoreCase(keyword)) {
                        points = 1.5;
                    } else if (normalizeString(argProp).equals(normalizeString(keyword))) {
                        points = 1.2;
                    }
                    totalScore += points;
                    break;
                }
            }
            if (!matched) totalScore += 0.1;
        }
        return totalScore / keywords.size();
    }

    private Set<String> normalizeOriginLabels(Graph g, String originalLabel) {
        Set<String> normalized = new HashSet<>();
        normalized.add(originalLabel);

        Node originUri = NodeFactory.createURI(ncl + originalLabel);
        ExtendedIterator<Triple> itBinding = g.find(Node.ANY, ABOUT_ORIGIN, originUri);
        while (itBinding.hasNext()) {
            Node bindingNode = itBinding.next().getSubject();
            ExtendedIterator<Triple> itSyn = g.find(bindingNode, ORIGIN_SYNONYM_LABELS, Node.ANY);
            while (itSyn.hasNext()) {
                Node val = itSyn.next().getObject();
                if (val.isLiteral()) {
                    String synStr = val.getLiteralLexicalForm();
                    if (synStr != null) {
                        String[] syns = synStr.split(",");
                        for (String syn : syns) {
                            String norm = syn.trim();
                            if (!norm.isEmpty()) normalized.add(norm);
                        }
                    }
                }
            }
            itSyn.close();
        }
        itBinding.close();

        return normalized;
    }

    private String getOriginFilteringRule(Graph g, String originType) {
        Node originUri = NodeFactory.createURI(ncl + originType);
        ExtendedIterator<Triple> itBinding = g.find(Node.ANY, ABOUT_ORIGIN, originUri);
        while (itBinding.hasNext()) {
            Node bindingNode = itBinding.next().getSubject();
            ExtendedIterator<Triple> itRule = g.find(bindingNode, ORIGIN_FILTERING_RULE, Node.ANY);
            while (itRule.hasNext()) {
                Node val = itRule.next().getObject();
                if (val.isLiteral()) {
                    String rule = val.getLiteralLexicalForm();
                    if (rule != null) {
                        itRule.close();
                        itBinding.close();
                        return rule.trim();
                    }
                }
            }
            itRule.close();
        }
        itBinding.close();
        return null;
    }

    private boolean applyFilteringRule(Graph g, Node argumentNode, String filteringKeyword) {
        Set<String> props = new HashSet<>();

        ExtendedIterator<Triple> itValue = g.find(argumentNode, PRODUCT_ARG_VALUE_PROPERTY, Node.ANY);
        while (itValue.hasNext()) {
            Node val = itValue.next().getObject();
            if (val.isLiteral()) {
                String prop = val.getLiteralLexicalForm().toLowerCase().trim();
                if (!prop.isEmpty()) props.add(prop);
            }
        }
        itValue.close();

        ExtendedIterator<Triple> itName = g.find(argumentNode, PRODUCT_ARG_NAME_PROPERTY, Node.ANY);
        while (itName.hasNext()) {
            Node val = itName.next().getObject();
            if (val.isLiteral()) {
                String prop = val.getLiteralLexicalForm().toLowerCase().trim();
                if (!prop.isEmpty()) props.add(prop);
            }
        }
        itName.close();

        String keyword = filteringKeyword.toLowerCase();
        return props.stream().anyMatch(p -> p.contains(keyword));
    }

    private void createLinkToArgument(Graph g, Node productNode, Node argumentNode, Node originNode, String propertyName, RuleContext context) {
        String linkId = "LinkToArgument_" + System.currentTimeMillis() + "_" + Math.abs((productNode.toString() + argumentNode.toString()).hashCode());
        Node linkNode = NodeFactory.createURI(ncl + linkId);

        Triple t1 = Triple.create(productNode, HAS_LINK_TO_ARGUMENT, linkNode);
        context.add(t1);
        Triple t2 = Triple.create(linkNode, HAS_REFERENCE_PRODUCT_ARGUMENT, argumentNode);
        context.add(t2);

        Node initiatorValue = NodeFactory.createLiteralString("ControlledOriginType");
        Triple t3 = Triple.create(linkNode, INITIATOR, initiatorValue);
        context.add(t3);

        Node nameValue = NodeFactory.createLiteralString(propertyName);
        Triple t5 = Triple.create(linkNode, LINK_NAME_PROPERTY, nameValue);
        context.add(t5);

        String originUri = originNode.isURI() ? originNode.getURI() : originNode.toString();
        Node valueNode = NodeFactory.createLiteralString(originUri);
        Triple t6 = Triple.create(linkNode, LINK_VALUE_PROPERTY, valueNode);
        context.add(t6);
    }

    private boolean isOriginRequired(Graph g, Node bindingNode) {
        ExtendedIterator<Triple> itRequired = g.find(bindingNode, ORIGIN_REQUIRED, Node.ANY);
        while (itRequired.hasNext()) {
            Node val = itRequired.next().getObject();
            if (val.isLiteral()) {
                String required = val.getLiteralLexicalForm();
                if (required != null) {
                    String req = required.trim().toLowerCase();
                    if (req.equals("oui") || req.equals("yes") || req.equals("ok")) {
                        itRequired.close();
                        return true;
                    }
                }
            }
        }
        itRequired.close();
        return false;
    }

    private String getArgumentProperty(Graph g, Node argumentNode, Node property) {
        ExtendedIterator<Triple> it = g.find(argumentNode, property, Node.ANY);
        while (it.hasNext()) {
            Node val = it.next().getObject();
            if (val.isLiteral()) {
                String result = val.getLiteralLexicalForm();
                it.close();
                return result;
            }
        }
        it.close();
        return null;
    }

    private boolean matchesAnyArgumentProperty(String metadataProp, Set<String> argProperties) {
        for (String argProp : argProperties) {
            if (argProp.equalsIgnoreCase(metadataProp)) return true;
            if (normalizeString(argProp).equals(normalizeString(metadataProp))) return true;
            if (tokenOverlap(metadataProp, argProp) >= 0.5) return true;
            String normMeta = normalizeString(metadataProp);
            String normArg = normalizeString(argProp);
            if (!normMeta.isEmpty() && !normArg.isEmpty() && (normMeta.contains(normArg) || normArg.contains(normMeta))) return true;
        }
        return false;
    }

    private double tokenOverlap(String s1, String s2) {
        Set<String> tokens1 = tokenize(normalizeString(s1));
        Set<String> tokens2 = tokenize(normalizeString(s2));
        if (tokens1.isEmpty() && tokens2.isEmpty()) return 1.0;
        if (tokens1.isEmpty() || tokens2.isEmpty()) return 0.0;
        Set<String> intersection = new HashSet<>(tokens1);
        intersection.retainAll(tokens2);
        Set<String> union = new HashSet<>(tokens1);
        union.addAll(tokens2);
        return (double) intersection.size() / union.size();
    }

    private Set<String> tokenize(String str) {
        Set<String> tokens = new HashSet<>();
        String[] parts = str.split("\\s+");
        for (String part : parts) {
            part = part.trim();
            if (!part.isEmpty() && part.length() > 1) tokens.add(part);
        }
        return tokens;
    }

    private String normalizeString(String str) {
        if (str == null) return "";
        return str.toLowerCase()
                .replaceAll("[àáâãäå]", "a")
                .replaceAll("[èéêë]", "e")
                .replaceAll("[ìíîï]", "i")
                .replaceAll("[òóôõö]", "o")
                .replaceAll("[ùúûü]", "u")
                .replaceAll("[ýÿ]", "y")
                .replaceAll("[ç]", "c")
                .replaceAll("[^a-z0-9]", "")
                .trim();
    }
}
